<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Elden Ring Overlay</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  font-family: Georgia, serif;
  color: #e6dcc8;
  overflow: hidden;
}

.wrapper {
  position: relative;
  width: 420px;
  height: 560px;
  padding: 18px;
  box-sizing: border-box;
  overflow: hidden;
  padding: 20px;

  background: linear-gradient(
    rgba(0, 0, 0, 0.75),
    rgba(10, 10, 10, 0.85)
  );

  border-radius: 14px;

  box-shadow:
    0 0 25px rgba(0, 0, 0, 0.6),
    0 0 12px rgba(201, 164, 74, 0.4);

  backdrop-filter: blur(4px);
}


.wrapper::before {
  content: "";
  position: absolute;
  inset: 1px;
  border-radius: 14px;
  pointer-events: none;

  box-shadow:
    inset 0 0 30px rgba(201, 164, 74, 0.15),
    inset 0 0 60px rgba(0, 0, 0, 0.7);
}

/* Goldrahmen als Overlay */
.wrapper::after {
  content: "";
  position: absolute;
  inset: 1px;
  border-radius: 14px;
  pointer-events: none;
  border: 2px solid #c9a44a;
  box-sizing: border-box;
}

.scroll {
  height: 480px;
  overflow: hidden;
}


/* Scrollbar unsichtbar */
.scroll::-webkit-scrollbar {
  width: 0;
}

.area {
  margin-bottom: 22px;
}

.area-title {
  font-size: 18px;
  padding-bottom: 3px;
  margin-bottom: 4px;
  position: relative;
}

.area-title::after {
  content: "";
  display: block;
  width: 85%;
  height: 1px;
  background: #7d6a3d;
  margin-top: 3px;
}

.area-progress {
  font-size: 14px;
  opacity: 0.7;
  margin-bottom: 6px;
}

.boss {
  display: flex;
  justify-content: flex-start; 
  align-items: center;
  padding: 2px 0;
}

.boss-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.boss.done .boss-name {
  opacity: 0.35;          /* Name ausgegraut */
}

.deaths {
  color: #c9a44a;
  min-width: 45px; 
  text-align: left;
  margin-right: 10px;
}

.main-boss {
  color: #e3b873;
  font-weight: bold;
}

/* Angepinnte Bosse */
.pinned-container {
  border-bottom: 2px solid #7d6a3d;
  margin-bottom: 15px;
  padding-bottom: 10px;
}

.pinned-boss {
  background: rgba(201, 164, 74, 0.1);
  padding: 4px 8px;
  border-radius: 4px;
  margin-bottom: 4px;

  animation: pinnedPulse 2.5s ease-in-out infinite;
}


.header-stats {
  font-size: 18px;
  margin-bottom: 10px;
  color: #c9a44a;
  display: flex;
  gap: 20px;
}

@keyframes deathPulse {
  0%   { transform: scale(1); }
  30%  { transform: scale(1.25); color: #e05a4f; }
  60%  { transform: scale(0.95); }
  100% { transform: scale(1); }
}

.death-animate {
  animation: deathPulse 0.8s ease-out;
}

@keyframes bossPulse {
  0%   { transform: scale(1); }
  30%  { transform: scale(1.2); color: #e3b873; }
  60%  { transform: scale(0.95); }
  100% { transform: scale(1); }
}

@keyframes pinnedPulse {
  0%   { box-shadow: 0 0 4px rgba(201,164,74,0.15); }
  50%  { box-shadow: 0 0 18px rgba(201,164,74,0.45); }
  100% { box-shadow: 0 0 4px rgba(201,164,74,0.15); }
}

.boss-animate {
  animation: bossPulse 0.8s ease-out;
}

/* ================= VICTORY OVERLAY ================= */

.victory-overlay {
  position: absolute;
  width: 420px;
  height: 560px;
  background: radial-gradient(circle, rgba(201,164,74,0.3), rgba(0,0,0,0.9));
  top: 0;
  left: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  opacity: 0;
  z-index: 100; /* hoch genug, um √ºber allem zu liegen */
}

.victory-text {
  font-size: 42px;
  color: #e3b873;
  text-shadow: 0 0 20px #c9a44a, 0 0 40px #c9a44a;
  letter-spacing: 4px;
  transform: scale(0.8);
  opacity: 0;
  text-align: center;
}

/* Animationen */
.victory-show {
  animation: overlayFade 3s ease forwards;
}

.victory-text-show {
  animation: textPop 3s ease forwards;
}

@keyframes overlayFade {
  0% { opacity: 0; }
  20% { opacity: 1; }
  80% { opacity: 1; }
  100% { opacity: 0; }
}

@keyframes textPop {
  0% { opacity: 0; transform: scale(0.6); }
  20% { opacity: 1; transform: scale(1.1); }
  80% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(0.9); }
}

/* ================= PARTICLES ================= */

.particle {
  position: absolute;
  width: 6px;
  height: 6px;
  background: #c9a44a;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0.9;
  animation: explode 1s ease-out forwards;
}

@keyframes explode {
  0% { transform: translate(0,0) scale(1); opacity: 1; }
  100% { transform: translate(var(--x), var(--y)) scale(0.2); opacity: 0; }
}


</style>
</head>

<body>
<div class="wrapper">
    <div class="header-stats">
        <span id="total-deaths">üíÄ Tode: 0</span>
        <span id="total-boss-progress">üèÜ Bosse: 0 / 0</span>
    </div>

    <div id="boss-timer" style="
      font-size:18px;
      margin-bottom:12px;
      color:#c9a44a;
      display:none;
    ">
    ‚è≥ Aktueller Boss: 00:00:00
  </div>

    <div id="pinned-area" class="pinned-container" style="display: none;"></div>

  <div class="scroll" id="content"></div>
  <div class="victory-overlay" id="victoryOverlay">
  <div class="victory-text" id="victoryText">BOSS ERLEDIGT</div>
  </div>

</div>

<script>

/* ===== VICTORY CONFIG ===== */

const VICTORY_DELAY = 2000;
const PARTICLE_COUNT = 50;

let previousBossStates = {};
let autoScrollPaused = false;

let lastGlobalDeaths = 0;
let lastDoneBosses = 0;
let lastTotalBosses = 0;

const MAIN_BOSSES = [
  "Margit, das Grausame Mal",
  "Godrick der Verpflanzte",
  "Rennala, K√∂nigin des Vollmonds",
  "Roter Wolf von Radagon",
  "Sternengei√üel Radahn",
  "G√∂tterverschlingende Schlange / Rykard, F√ºrst der Blasphemie",
  "Drachenbaumw√§chter",
  "Godfrey, Erster Eldenf√ºrst",
  "Morgott, K√∂nig des Mals",
  "Mohg, F√ºrst des Blutes",
  "Feuerriese",
  "Bestienkleriker / Maliketh, die Schwarze Klinge",
  "Duo der G√∂tterskalpe",
  "Malenia, Klinge von Miquella",
  "Godfrey, Erster Eldenf√ºrst (Hoarah Loux)",
  "Sir Gideon Ofnir, der Allwissende",
  "Radagon von der Goldenen Ordnung / Eldenbestie",
  "Rellana Twin Moon Knight",
  "Divine Beast Dancing Lion",
  "Messmer the Impaler + Base Serpent Messmer",
  "Bayle the Dread",
  "Midra Lord of Frenzied Flame",
  "Commander Gaius",
  "Romina, Saint of the Bud",
  "Promised Consort + Radahn Consort of Miquella",
];

const SPREADSHEET_ID = "1r9BzZJYFrk4rQLlMn4ZPBBUuc8u_peqwThTi1UTCQcE";
const URL = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?sheet=OBS_OVERLAY&tqx=out:json`;

/* ================= TIMER ENGINE ================= */

let timerRunning = false;
let timerStart = 0;
let elapsedAtStop = 0;       // ‚úÖ FIX 3: store elapsed time when paused
let currentBossName = "Aktueller Boss";
let timerVisible = false;
let lastResetState = false;

function updateTimerDisplay() {
  const timerElement = document.getElementById("boss-timer");
  if (!timerElement) return;

  // ‚úÖ FIX 2: This is the ONLY place that touches the DOM
  timerElement.style.display = timerVisible ? "block" : "none";

  // ‚úÖ FIX 3: Use frozen elapsed time when stopped, live time when running
  const diff = timerRunning
    ? Math.floor((Date.now() - timerStart) / 1000)
    : Math.floor(elapsedAtStop / 1000);

  const hours   = String(Math.floor(diff / 3600)).padStart(2, "0");
  const minutes = String(Math.floor((diff % 3600) / 60)).padStart(2, "0");
  const seconds = String(diff % 60).padStart(2, "0");

  timerElement.innerText = `‚è≥ ${currentBossName}: ${hours}:${minutes}:${seconds}`;
}

setInterval(updateTimerDisplay, 1000);

async function loadData() {
  const res  = await fetch(URL + "&t=" + Date.now());
  const text = await res.text();
  const json = JSON.parse(text.substring(47).slice(0, -2));
  const rows = json.table.rows;

  const isTrue = v => [true, "TRUE", "WAHR", 1].includes(v);

  const baseGameFlag = isTrue(rows[0]?.c[15]?.v); // P1
  const dlcFlag      = isTrue(rows[1]?.c[15]?.v); // P2

  const timerStartFlag   = rows[0]?.c[10]?.v;
  const timerResetFlag   = rows[1]?.c[10]?.v;
  const timerVisibleFlag = rows[0]?.c[12]?.v;

  const startChecked   = isTrue(timerStartFlag);
  const resetChecked   = isTrue(timerResetFlag);
  const visibleChecked = isTrue(timerVisibleFlag);


  /* ===== RESET ===== */
  if (resetChecked && !lastResetState) {
    // Only reset on the RISING EDGE (false ‚Üí true), not every poll cycle
    timerStart    = Date.now();
    elapsedAtStop = 0;
    if (timerRunning) {
      timerStart = Date.now(); // keep running from 0
    }
  }
  lastResetState = resetChecked;

  /* ===== START / STOP ===== */
  // ‚úÖ FIX 1+3: K1 is solely responsible for running state
  if (startChecked) {
    if (!timerRunning) {
      timerStart    = Date.now() - elapsedAtStop; // resume from where it stopped
      timerRunning  = true;
    }
  } else {
    if (timerRunning) {
      elapsedAtStop = Date.now() - timerStart;    // freeze elapsed time on stop
      timerRunning  = false;
    }
  }

  /* ===== SICHTBARKEIT ===== */
  // ‚úÖ FIX 4: Simple direct assignment, no unnecessary guard
  timerVisible = visibleChecked;

  // ‚úÖ FIX 2: No DOM updates here ‚Äî updateTimerDisplay() handles all rendering


  const areas = {};
  let globalTotalBosses = 0;
  let globalDoneBosses = 0;

  // ================================
// GESAMT TODE (abh√§ngig von P1 / P2)
// ================================

  // J2 = Zeile 2 ‚Üí index 1
  const baseDeaths = Number(rows[1]?.c[9]?.v) || 0;
  
  // J171 = Zeile 171 ‚Üí index 170
  const dlcDeaths  = Number(rows[170]?.c[9]?.v) || 0;
  
  let globalDeaths = 0;
  
  if (baseGameFlag && dlcFlag) {
    globalDeaths = baseDeaths + dlcDeaths;
  } else if (baseGameFlag) {
    globalDeaths = baseDeaths;
  } else if (dlcFlag) {
    globalDeaths = dlcDeaths;
  } else {
    globalDeaths = 0;
  }

  rows.forEach((r, index) => {

  const sheetRow = index + 1; // echte Tabellenzeile

  const area = r.c[0]?.v?.trim();
  const boss = r.c[1]?.v?.trim();

  // ================================
  // HEADER & UNG√úLTIGE ZEILEN BLOCKEN
  // ================================

  // Header-Zeile ignorieren
  if (area === "Gebiet" && boss === "Boss") return;

  // Leere Zeilen ignorieren
  if (!area || !boss) return;

  // Trennzeile 170 ignorieren
  if (sheetRow === 170) return;

  // ================================
  // BASE / DLC FILTER
  // ================================

  const isBaseGame = sheetRow >= 3 && sheetRow <= 167;
  const isDLC      = sheetRow >= 169 && sheetRow <= 212;

  // Wenn Base Game Boss aber Base deaktiviert ‚Üí √ºberspringen
  if (isBaseGame && !baseGameFlag) return;

  // Wenn DLC Boss aber DLC deaktiviert ‚Üí √ºberspringen
  if (isDLC && !dlcFlag) return;

  // Alles au√üerhalb dieser Bereiche ignorieren
  if (!isBaseGame && !isDLC) return;

  // ================================
  // NORMALE BOSS-LOGIK
  // ================================

  const rawDone   = r.c[2]?.v;
  const done      = [true, "TRUE", "WAHR", 1].includes(rawDone);

  const rawPinned = r.c[4]?.v;
  const pinned    = [true, "TRUE", "WAHR", 1].includes(rawPinned);

  const deaths = Number(r.c[3]?.v) || 0;
  const key = area + "|" + boss;

  if (!(key in previousBossStates)) {
    previousBossStates[key] = done;
  } else if (!previousBossStates[key] && done) {

    if (MAIN_BOSSES.includes(boss)) {
      setTimeout(() => {
        const bossElements = document.querySelectorAll(".boss");
        bossElements.forEach(el => {
          if (el.querySelector(".boss-name")?.innerText === boss) {
            triggerVictory(el);
          }
        });
      }, 100);
    }
  }

  previousBossStates[key] = done;

  globalTotalBosses++;
  if (done) globalDoneBosses++;

  if (!areas[area]) {
    const rawCollapsed = r.c[5]?.v;

    areas[area] = {
      total: 0,
      done: 0,
      bosses: [],
      collapsed: [true, "TRUE", "WAHR", 1].includes(rawCollapsed)
    };
  }

  areas[area].total++;
  if (done) areas[area].done++;

  areas[area].bosses.push({ boss, done, deaths, pinned });

});


  // Header aktualisieren
  const deathEl = document.getElementById("total-deaths");
  if (globalDeaths !== lastGlobalDeaths) {
    deathEl.classList.remove("death-animate");
    void deathEl.offsetWidth;
    deathEl.classList.add("death-animate");
  }
  deathEl.innerText = `üíÄ Tode: ${globalDeaths}`;
  lastGlobalDeaths = globalDeaths;

  const bossEl = document.getElementById("total-boss-progress");
  if (globalDoneBosses !== lastDoneBosses || globalTotalBosses !== lastTotalBosses) {
    bossEl.classList.remove("boss-animate");
    void bossEl.offsetWidth;
    bossEl.classList.add("boss-animate");
  }
  bossEl.innerText = `üèÜ Bosse: ${globalDoneBosses} / ${globalTotalBosses}`;
  lastDoneBosses = globalDoneBosses;
  lastTotalBosses = globalTotalBosses;

  // Render
  // 1. Render Pinned Bosses
  const pinnedArea = document.getElementById("pinned-area");
  pinnedArea.innerHTML = "";
  let hasPinned = false;

  // Alle Bosse aus allen Gebieten sammeln, die gepinnt sind
  const allPinned = [];
  Object.values(areas).forEach(areaData => {
    areaData.bosses.forEach(b => {
      if (b.pinned) allPinned.push(b);
    });
  });

  if (allPinned.length > 0) {
    hasPinned = true;
    allPinned.forEach(b => {
      const bossDiv = document.createElement("div");
      const normalize = str => str.trim().toLowerCase().replace(/\s+/g, " ");
      const isMain = MAIN_BOSSES
      .map(normalize)
      .includes(normalize(b.boss));
      bossDiv.className = "boss pinned-boss" + (b.done ? " done" : "") + (isMain ? " main-boss" : "");
      
      bossDiv.innerHTML = `
        <span class="deaths">üìå ${b.deaths}</span>
        <span class="boss-name">${b.boss}</span>
      `;
      pinnedArea.appendChild(bossDiv);
    });
  }
  pinnedArea.style.display = hasPinned ? "block" : "none";

  // 2. Render Normal Areas
  const content = document.getElementById("content");
  content.innerHTML = "";

  Object.entries(areas).forEach(([area, data]) => {
    const areaDiv = document.createElement("div");
    areaDiv.className = "area";

    areaDiv.innerHTML = `
      <div class="area-title">
        ${data.collapsed ? "‚ñ∂" : "‚ñº"} ${area}
      </div>
      <div class="area-progress">${data.done} / ${data.total}</div>
    `;

    if (!data.collapsed) {
      data.bosses.forEach(b => {
        const bossDiv = document.createElement("div");
        const isMain = MAIN_BOSSES.includes(b.boss);

        // Hier lassen wir die normale Darstellung, aber ohne die pinned-boss Klasse
        let classes = "boss" + (b.done ? " done" : "") + (isMain ? " main-boss" : "");
        bossDiv.className = classes;

        bossDiv.innerHTML = `
          <span class="deaths">‚Ä† ${b.deaths}</span>
          <span class="boss-name">${b.boss}</span>
        `;

        areaDiv.appendChild(bossDiv);
      });
    }
    content.appendChild(areaDiv);
  });
}

/* ================= VICTORY SYSTEM ================= */

function triggerVictory(el) {

  autoScrollPaused = true;

  const container = document.getElementById("content");

  const topPos = el.offsetTop - container.clientHeight / 2;

  container.scrollTo({
    top: topPos,
    behavior: "smooth"
  });

  setTimeout(() => {

    showOverlay();
    spawnParticles();

    el.style.transition = "all .4s ease";
    el.style.transform = "scale(1.15)";
    el.style.boxShadow = "0 0 25px #c9a44a";

    setTimeout(() => {
      el.style.transform = "scale(1)";
      el.style.boxShadow = "none";
      autoScrollPaused = false;
    }, 2500);

  }, VICTORY_DELAY);
}

function showOverlay(){
  const overlay=document.getElementById("victoryOverlay");
  const text=document.getElementById("victoryText");

  overlay.classList.add("victory-show");
  text.classList.add("victory-text-show");

  setTimeout(()=>{
    overlay.classList.remove("victory-show");
    text.classList.remove("victory-text-show");
  },3000);
}

function spawnParticles(){
  const wrapper=document.querySelector(".wrapper");

  for(let i=0;i<PARTICLE_COUNT;i++){
    const p=document.createElement("div");
    p.className="particle";

    const angle=Math.random()*2*Math.PI;
    const distance=120+Math.random()*80;

    const x=Math.cos(angle)*distance+"px";
    const y=Math.sin(angle)*distance+"px";

    p.style.left="50%";
    p.style.top="50%";
    p.style.setProperty("--x",x);
    p.style.setProperty("--y",y);

    wrapper.appendChild(p);
    setTimeout(()=>p.remove(),1000);
  }
}


loadData();
setInterval(loadData, 5000);

// Auto-Scroll
let scrollDir = 1;
setInterval(() => {
  if (autoScrollPaused) return;

  const el = document.getElementById("content");
  if (!el) return;

  el.scrollTop += scrollDir;

  if (el.scrollTop + el.clientHeight >= el.scrollHeight) scrollDir = -1;
  if (el.scrollTop <= 0) scrollDir = 1;

}, 50);



</script>
</body>
</html>
















